use glfw::{Modifiers, WindowEvent, Action, Key as GLFWKey};
use std::collections::HashSet;
use crate::input::Input;

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub struct Key {
    pub key: GLFWKey,
    pub scancode: i32, // Code for key generated by OS
    pub modifiers: Modifiers // pressed modifier keys like ctrl, alt, etc.
}

#[derive(Debug, Copy, Clone)]
pub struct Character {
    pub character: char,
    pub modifiers: Modifiers
}

#[derive(Debug, Clone)]
pub struct KeyBoard {
    pressed_keys: HashSet<Key>,
    released_keys: HashSet<Key>,
    new_char: Character
}

impl KeyBoard {
    pub fn get_pressed_keys(&self) -> &HashSet<Key> {
        &self.pressed_keys
    }

    pub fn get_released_keys(&self) -> &HashSet<Key> {
        &self.pressed_keys
    }
}

impl Input for KeyBoard {
    fn new() -> Self {
        KeyBoard {
            pressed_keys: HashSet::new(),
            released_keys: HashSet::new(),
            new_char: Character {
                character: char::default(),
                modifiers: Modifiers::empty()
            }
        }
    }

    fn update(&mut self, event: WindowEvent) {
        match event  {
            WindowEvent::Key(key, scancode, action, modifiers) => {
                match action {
                    Action::Press => {
                        self.pressed_keys.insert(
                            Key {
                                key,
                                scancode,
                                modifiers
                            }
                        );
                    },
                    Action::Release => {
                        self.released_keys.insert(
                            Key {
                                key,
                                scancode,
                                modifiers
                            }
                        );
                    },
                    _ => {/*
                        Currently uninterested in this action.
                        NOT to be mistaken with isKeyHeldDown
                     */}
                }
            },
            // Char and CharModifiers represent software characters instead of physical keys
            // This is for excepting text input and handling characters that require multi-key inputs
            WindowEvent::Char(character) => {
                self.new_char = Character {
                    character,
                    modifiers: Modifiers::empty()
                }
            },
            WindowEvent::CharModifiers(character, modifiers) => {
                self.new_char = Character { character, modifiers }
            },
            _ => {/* Ignore anything unrelated to the keyboard */}
        }
    }

    fn clear(&mut self) {
        self.new_char = Character { character: char::default(), modifiers: Modifiers::empty() };
        self.released_keys.clear();
        self.pressed_keys.clear();
    }
}